// =====================================================
// SOLUCIÓN PARA CHATS DUPLICADOS DE GRUPOS
// =====================================================

/**
 * PROBLEMA:
 * Cuando alguien de un grupo escribe, Baileys crea un chat individual separado
 * aunque ya exista el chat del grupo donde está esa persona.
 *
 * SOLUCIÓN:
 * 1. Verificar si el remitente pertenece a algún grupo existente
 * 2. Si pertenece a un grupo, agregar el mensaje al chat del grupo
 * 3. Si no pertenece a ningún grupo, crear chat individual
 */

private async handleIncomingMessageGroupAware(sessionId: string, msg: any) {
  try {
    if (!msg.message || msg.key.fromMe) return;

    const messageContent =
      msg.message.conversation ||
      msg.message.extendedTextMessage?.text ||
      msg.message.imageMessage?.caption ||
      "[Multimedia]";

    const from = msg.key.remoteJid; // Número individual que envió el mensaje
    const messageId = msg.key.id;
    const timestamp = new Date(msg.messageTimestamp * 1000);

    // Buscar si este número pertenece a algún grupo donde participamos
    const groupChats = await Chat.find({
      sessionId,
      chatId: { $regex: /@g\.us$/ } // Solo grupos
    });

    let targetChatId = from; // Por defecto, chat individual
    let targetChat = null;
    let isGroupMember = false;

    // Verificar si el remitente está en algún grupo
    for (const groupChat of groupChats) {
      try {
        // Obtener participantes del grupo usando Baileys
        const session = this.sessions[sessionId];
        if (session?.sock) {
          const groupMetadata = store ? store.groupMetadata?.[groupChat.chatId] : null;

          if (groupMetadata?.participants) {
            const participants = Object.keys(groupMetadata.participants);
            if (participants.includes(from)) {
              // El remitente está en este grupo
              targetChatId = groupChat.chatId; // Usar el grupo como chat objetivo
              targetChat = groupChat;
              isGroupMember = true;
              break;
            }
          }
        }
      } catch (error) {
        console.error('Error verificando participantes del grupo:', error);
      }
    }

    // Si no está en ningún grupo, usar chat individual
    if (!isGroupMember) {
      targetChat = await Chat.findOne({ chatId: from, sessionId });
    }

    // Crear o actualizar el chat objetivo
    if (!targetChat) {
      const contactName = msg.pushName || from.split("@")[0] || "Desconocido";
      targetChat = await Chat.create({
        chatId: targetChatId,
        sessionId,
        name: contactName,
        phone: from,
        lastMessageTime: timestamp,
        unreadCount: 1,
      });
    } else {
      targetChat.lastMessage = messageContent;
      targetChat.lastMessageTime = timestamp;
      targetChat.unreadCount += 1;
      targetChat.updatedAt = new Date();
      await targetChat.save();
    }

    // Guardar el mensaje con el chatId correcto (grupo o individual)
    await Message.create({
      messageId,
      chatId: targetChatId, // <- Aquí va el chatId correcto
      sessionId,
      from,
      to: sessionId,
      body: messageContent,
      fromMe: false,
      timestamp,
      messageType: Object.keys(msg.message)[0],
      status: "delivered",
    });

    // Emitir evento con el chatId correcto
    this.io?.emit("message", {
      sessionId,
      from,
      chatId: targetChatId, // <- Chat correcto
      text: messageContent,
      timestamp: timestamp.toISOString(),
      messageId,
      isGroupMessage: isGroupMember // Indicar si es mensaje de grupo
    });

  } catch (error) {
    console.error("Error handling group-aware incoming message:", error);
  }
}

// =====================================================
// CONFIGURACIÓN PARA ACTIVAR LA SOLUCIÓN
// =====================================================

// En el método createSession, reemplazar la línea:
// sock.ev.on("messages.upsert", async (m) => {
//   if (m.type === "notify") {
//     for (const msg of m.messages) {
//       await this.handleIncomingMessage(sessionId, msg);
//     }
//   }
// });

// Por:
// sock.ev.on("messages.upsert", async (m) => {
//   if (m.type === "notify") {
//     for (const msg of m.messages) {
//       await this.handleIncomingMessageGroupAware(sessionId, msg);
//     }
//   }
// });

// =====================================================
// ENDPOINT ADICIONAL PARA GESTIÓN DE GRUPOS
// =====================================================

/**
 * NUEVO ENDPOINT SUGERIDO:
 * GET /api/sessions/{sessionId}/groups/{groupId}/members
 *
 * Para obtener los miembros de un grupo y poder verificar
 * si un número pertenece a un grupo específico
 */

// =====================================================
// EJEMPLO DE USO EN EL FRONTEND
// =====================================================

/*
// En el frontend, para mostrar mensajes correctamente:

socket.on('message', (data) => {
  const { chatId, from, text, isGroupMessage } = data;

  if (isGroupMessage) {
    // Es un mensaje de alguien en un grupo
    console.log(`Mensaje en grupo ${chatId} de ${from}: ${text}`);
    // Mostrar como: "Juan en Grupo Familiar: Hola"
  } else {
    // Es un mensaje individual
    console.log(`Mensaje individual de ${from}: ${text}`);
    // Mostrar normalmente
  }
});

// Para verificar si alguien está en un grupo:
const checkGroupMember = async (sessionId, groupId, phoneNumber) => {
  try {
    const response = await fetch(
      `http://localhost:5000/api/sessions/${sessionId}/groups/${groupId}/members`
    );
    const members = await response.json();

    return members.some(member => member.id === phoneNumber);
  } catch (error) {
    console.error('Error checking group member:', error);
    return false;
  }
};
*/

// =====================================================
// CONFIGURACIÓN DE BASE DE DATOS ADICIONAL
// =====================================================

/*
// Agregar a tu modelo Chat si no lo tienes:
interface Chat {
  // ... campos existentes
  isGroupChat?: boolean;        // true si es un grupo
  groupMembers?: string[];      // IDs de miembros del grupo
  lastGroupActivity?: Date;     // Última actividad del grupo
}

// En el schema de Chat:
const ChatSchema = new Schema({
  // ... campos existentes
  isGroupChat: { type: Boolean, default: false },
  groupMembers: [{ type: String }], // Array de IDs de participantes
  lastGroupActivity: { type: Date, default: Date.now },
});
*/

// =====================================================
// TESTING DE LA SOLUCIÓN
// =====================================================

/*
// Para probar la solución:

1. Crear un grupo en WhatsApp
2. Agregar participantes al grupo
3. Hacer que un participante del grupo envíe un mensaje
4. Verificar que NO se crea un chat individual separado
5. Verificar que el mensaje aparece en el chat del grupo
6. Comprobar en la DB que solo existe un chat (el del grupo)
*/

// =====================================================
// MIGRACIÓN DE DATOS EXISTENTES (OPCIONAL)
// =====================================================

/*
// Script para limpiar chats duplicados existentes:

const cleanupDuplicateChats = async () => {
  try {
    // Encontrar todos los chats individuales que pertenecen a grupos
    const individualChats = await Chat.find({
      chatId: { $regex: /@s\.whatsapp\.net$/ }
    });

    for (const chat of individualChats) {
      const phone = chat.chatId.split('@')[0];

      // Buscar si existe algún grupo que contenga este número
      const groupChats = await Chat.find({
        sessionId: chat.sessionId,
        chatId: { $regex: /@g\.us$/ },
        // Aquí necesitarías lógica para verificar miembros del grupo
      });

      // Si pertenece a un grupo, migrar mensajes y eliminar chat individual
      if (groupChats.length > 0) {
        console.log(`Migrando mensajes de ${chat.chatId} al grupo`);

        // Migrar mensajes al grupo
        await Message.updateMany(
          { chatId: chat.chatId, sessionId: chat.sessionId },
          { chatId: groupChats[0].chatId }
        );

        // Eliminar chat individual
        await Chat.deleteOne({ _id: chat._id });
      }
    }

    console.log('✅ Migración completada');
  } catch (error) {
    console.error('❌ Error en migración:', error);
  }
};
*/
